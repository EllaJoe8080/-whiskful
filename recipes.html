<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Whiskful Recipes</title>
    <style>
      /* Make the whole card clickable, but keep it BELOW the buttons */
.tile > a {
    position: absolute;
    inset: 0;
    z-index: 1;
    display: block;
    cursor: pointer;
  }

  /* Add focus outline for keyboard users */
  .tile > a:focus-visible {
    outline: 3px solid var(--brand);
    outline-offset: -3px;
  }

  /* Keep buttons above the link */
  .overlay {
    z-index: 2;
  }

  :root { --brand:#ff7a59; --bg:#fff8f3; --pin:#e60023;}

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background: var(--bg);
        color:#222;
      }

      /* Navbar */
      nav {
        position:sticky; top:0; z-index:1000;
        height:72px; padding:0 24px; background:#fff;
        box-shadow:0 2px 8px rgba(0,0,0,.06);
        display:flex; align-items:center; justify-content:space-between;
      }
      nav img.logo { max-height:140px; width:auto; display:block; }
      nav ul {
  list-style: none;
  display: flex;
  gap: 24px;
  margin-left: auto;   /* pushes menu to the right */
}

nav select#language-switcher {
  margin-left: 16px;   /* small gap after the menu */
}
      nav a { text-decoration:none; font-weight:600; color:#333; }
      nav a:hover { color:var(--brand); }

      /* Search bar */
      .search-wrap { display:flex; justify-content:center; margin:28px 0 8px; }
      .search-box { position:relative; width:min(640px,92%); }
      .search-box input {
        width:100%; padding:12px 16px;
        border:2px solid var(--brand); border-radius:999px;
        font-size:16px; background:#fff;
      }
      .search-box input:focus {
        border-color:#ff5a36; box-shadow:0 0 8px rgba(255,122,89,.3);
        outline: none;
      }
      .dangling-gif {
        position:absolute; top:-22px; right:-50px; width:100px;
        pointer-events:none; transform-origin:top center;
        animation:sway 2.5s ease-in-out infinite;
      }
      @keyframes sway {
        0%{transform:rotate(6deg)} 50%{transform:rotate(-6deg)} 100%{transform:rotate(6deg)}
      }

      /* Grid */
      .grid {
        width:min(1100px,94%);
        margin:12px auto 64px;
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(260px, 1fr));
        gap:12px;
      }

      .tile {
        background:#fff; border-radius:8px; overflow:hidden;
        box-shadow:0 1px 6px rgba(0,0,0,.05);
        transition:transform .15s ease, box-shadow .15s ease;
        position:relative;
      }
      .tile:hover { transform:translateY(-2px); box-shadow:0 10px 24px rgba(0,0,0,.12); }

      .thumb {
        aspect-ratio:2/3;
        background:#fafafa;
        display:flex; align-items:center; justify-content:center;
        padding:4px; /* keep some breathing room inside */
      }
      .thumb img {
        width:100%; height:100%; object-fit:cover; display:block;
      }

      /* Overlay for Save + Like */
      .overlay {
        position:absolute;
        inset:4px;  /* matches .thumb padding */
        pointer-events:none;
        opacity:0;
        transition:opacity .2s ease;
      }
      .tile:hover .overlay { opacity:1; }

      .save-btn, .icon-btn {
        position:absolute; top:10px; pointer-events:auto;
      }

      .save-btn {
        left:10px;
        border:0; border-radius:22px;
        background:var(--pin); color:#fff; font-weight:700;
        padding:8px 16px; font-size:14px; line-height:1;
        box-shadow:0 4px 12px rgba(0,0,0,.25);
        cursor:pointer;
        transition:transform .15s ease, background .15s ease;
      }
      .save-btn:hover { transform:scale(1.05); background:#c7001c; }

      .icon-btn {
        right:10px;
        width:36px; height:36px; border-radius:50%;
        display:grid; place-items:center;
        background:#fff; border:0; cursor:pointer;
        box-shadow:0 3px 10px rgba(0,0,0,.2);
        transition:transform .15s ease, background .15s ease;
      }
      .icon-btn:hover { transform:scale(1.06); }
      .icon-btn svg { display:block; }

      /* Responsive tweaks */
      @media (max-width:640px){
        .grid { grid-template-columns:repeat(auto-fill, minmax(160px, 1fr)); }
        .dangling-gif { right:-34px; top:-16px; width:74px; }
      }
      /* ---- Falling leaves layer ---- */
#leaf-layer{
  position: fixed;
  inset: 0;
  z-index: 0;            /* behind nav/grid */
  pointer-events: none;
  overflow: hidden;
}

/* a single leaf */
.leaf{
  --size: 80px;
  position: absolute;
  top: -12vh;
  width: var(--size);
  height: var(--size);
  opacity: 0;
  filter: drop-shadow(0 6px 6px rgba(0,0,0,.18));
  animation: leaf-move var(--dur) linear var(--delay) forwards;
}

@keyframes leaf-move {
  0%   { transform: translate(var(--start-x), -12vh) rotate(var(--rot-start)); opacity: 0; }
  10%  { opacity: 1; }
  25%  { transform: translate(calc(var(--start-x) + var(--amp)), 25vh) rotate(45deg); }
  50%  { transform: translate(calc(var(--start-x) - var(--amp)), 50vh) rotate(120deg); }
  75%  { transform: translate(calc(var(--start-x) + var(--amp)), 75vh) rotate(200deg); }
  100% { transform: translate(var(--end-x), 110vh) rotate(var(--rot-end)); opacity: 0; }
}

/* accessibility */
@media (prefers-reduced-motion: reduce){
  .leaf{ animation: none !important; opacity: 0; }
}
      /* Active states */
.save-btn.saved {
  background: #16a34a;   /* green when saved */
  box-shadow: 0 4px 12px rgba(22,163,74,.25);
}

.icon-btn.liked svg path {
  fill: red;              /* heart fills when liked */
  stroke: red;
}
      .recipe-meta{ padding:10px; text-align:center; }
.recipe-title{ margin:6px 0 8px; font-size:20px; font-weight:800; letter-spacing:.5px; }
.meta-row{ font-size:14px; opacity:.9; display:flex; gap:6px; justify-content:center; align-items:center; }
.card-actions{ display:flex; gap:6px; justify-content:center; padding:8px 0 12px; }
.card-actions button{
  border:0; border-radius:8px; padding:6px 10px; cursor:pointer;
  background:#eee;
}
.card-actions .save-card-btn{ background:var(--brand); color:#fff; }
.tile.editing .recipe-title, .tile.editing .servings, .tile.editing .totaltime{
  outline:2px dashed rgba(0,0,0,.15);
  outline-offset:2px;
}
      /* Hide meta + button under cards */
.recipe-meta,
.card-actions { display: none !important; }

      /* Hide everything under the image */
.tile .recipe-meta,
.tile .card-actions,
.tile .recipe-title { 
  display: none !important;
}
    </style>
  </head>
  <body>
    <!-- Falling leaves background layer -->
<div id="leaf-layer" aria-hidden="true"></div>
    <!-- Navbar -->
    <nav>
  <a href="index.html"><img src="/logo.png" alt="Whiskful logo" class="logo" /></a>
  <ul>
    <li><a href="recipes.html" data-translate>Recipes</a></li>
    <li><a href="#" data-translate>Community</a></li>
    <li><a href="#" data-translate>About</a></li>
  </ul>
  <select id="language-switcher" aria-label="Change language">
    <option value="en">English</option>
    <option value="es">Español</option>
    <option value="fr">Français</option>
    <option value="ar">العربية</option>
    <option value="zh">中文</option>
  </select>
</nav>

    <!-- Search -->
    <div class="search-wrap">
      <div class="search-box">
        <input
  type="text"
  placeholder="Search recipes..."
  data-translate-attr="placeholder"
/>
        <img src="/images/cherries.gif" alt="" class="dangling-gif" />
      </div>
    </div>

    <!-- Grid -->
    <main class="grid">
      <!-- pistachio-chocolate-roll -->
      <figure class="tile" data-id="pistachio-roll">
  <div class="thumb">
    <img src="/images/pistachio-chocolate-roll.png" alt="Pistachio Chocolate Swiss Roll" loading="lazy" />
  </div>

  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div>

<a href="pistachio-roll.html" aria-label="View Pistachio Chocolate Swiss Roll recipe"></a>
</figure>
 <!-- Pumpkin Cheesecake Truffles -->
  <figure class="tile" data-id="pumpkin-truffles">
  <div class="thumb">
    <img src="/images/pumpkin cheesecake truffles.jpeg" alt="Pumpkin Cheesecake Truffles" loading="lazy" />
  </div>
  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div>
  <a href="pumpkin-truffles.html" aria-label="View Pumpkin Cheesecake Truffles recipe"></a>
</figure>
 <!-- Strawberry Meringue kisses -->
     <figure class="tile" data-id="strawberry-meringue">
  <div class="thumb">
    <img src="/images/Strawberry Meringue kisses.jpeg" alt="Strawberry Meringue Kisses" loading="lazy" />
  </div>
  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div><a href="strawberry-meringue.html" aria-label="View Strawberry Meringue Kisses recipe"></a>
</figure>
      
    </main>
    <script>
(() => {
  // stop if user prefers reduced motion
  if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

  const layer = document.getElementById('leaf-layer');
  if (!layer) return;

  // Put these four PNGs in /images/ (transparent backgrounds)
  const LEAVES = [
    '/images/leaf1.png',
    '/images/leaf2.png',
    '/images/leaf3.png',
    '/images/leaf4.png'
  ];

  const CFG = {
  minInterval: 400,   // slower spawn rate, not overwhelming
  maxInterval: 1200,
  minDur: 4500,       // smoother fall
  maxDur: 7500,
  minSize: 80,        // larger minimum
  maxSize: 150,       // larger maximum
  minAmp: 40,         // bigger sway
  maxAmp: 120,
  maxConcurrent: 8    // more leaves at once
};

  let live = 0;
  const rand = (a,b) => Math.random()*(b-a)+a;

  function spawnLeaf(){
    if (live >= CFG.maxConcurrent) return;

    const img = document.createElement('img');
    img.className = 'leaf';
    img.src = LEAVES[Math.floor(Math.random()*LEAVES.length)];

    const size    = rand(CFG.minSize, CFG.maxSize);
    const dur     = rand(CFG.minDur,  CFG.maxDur);
    const startX  = rand(0, innerWidth);
    const endX    = startX + rand(-140, 140);
    const amp     = rand(CFG.minAmp, CFG.maxAmp);

    img.style.setProperty('--size', `${size}px`);
    img.style.setProperty('--dur',  `${dur}ms`);
    img.style.setProperty('--delay', '0ms');
    img.style.setProperty('--start-x', `${startX}px`);
    img.style.setProperty('--end-x',   `${endX}px`);
    img.style.setProperty('--amp',     `${amp}px`);
    img.style.setProperty('--rot-start', `${rand(-25,25)}deg`);
    img.style.setProperty('--rot-end',   `${rand(-360,360)}deg`);
    img.style.left = `${startX}px`;

    img.addEventListener('animationend', () => { img.remove(); live--; }, {once:true});

    live++;
    layer.appendChild(img);
  }

  function loop(){
    spawnLeaf();
    setTimeout(loop, rand(CFG.minInterval, CFG.maxInterval));
  }
  requestAnimationFrame(loop);
})();
</script>
    <script>
(() => {
  const STORAGE_KEY = 'whiskful-tile-states';  // { [tileId]: { liked:bool, saved:bool } }

  function loadState() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
    catch { return {}; }
  }
  function saveState(state) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  // Apply saved state on load
  const state = loadState();
  document.querySelectorAll('.tile[data-id]').forEach(tile => {
    const id = tile.getAttribute('data-id');
    const s = state[id] || {};
    const saveBtn = tile.querySelector('.save-btn');
    const likeBtn = tile.querySelector('.icon-btn');
    const heartPath = likeBtn?.querySelector('svg path');

    // Saved
    if (s.saved) {
      saveBtn?.classList.add('saved');
      saveBtn?.setAttribute('aria-pressed', 'true');
      if (saveBtn) saveBtn.textContent = 'Saved';
    }

    // Liked
    if (s.liked) {
      likeBtn?.classList.add('liked');
      likeBtn?.setAttribute('aria-pressed', 'true');
      if (heartPath) {
        heartPath.setAttribute('fill', 'red');
        heartPath.setAttribute('stroke', 'red');
      }
    }
  });

  // Click handling (event delegation)
  document.addEventListener('click', (e) => {
    const saveBtn = e.target.closest('.save-btn');
    const likeBtn = e.target.closest('.icon-btn');

    if (!saveBtn && !likeBtn) return;

    const tile = e.target.closest('.tile[data-id]');
    if (!tile) return;
    const id = tile.getAttribute('data-id');
    state[id] ||= { liked: false, saved: false };

    // SAVE toggle
    if (saveBtn) {
      e.preventDefault();
      const isSaved = saveBtn.classList.toggle('saved');
      saveBtn.setAttribute('aria-pressed', String(isSaved));
      saveBtn.textContent = isSaved ? 'Saved' : 'Save';
      state[id].saved = isSaved;
      saveState(state);
      return;
    }

    // LIKE toggle
    if (likeBtn) {
      e.preventDefault();
      const isLiked = likeBtn.classList.toggle('liked');
      likeBtn.setAttribute('aria-pressed', String(isLiked));
      const heartPath = likeBtn.querySelector('svg path');
      if (heartPath) {
        if (isLiked) {
          heartPath.setAttribute('fill', 'red');
          heartPath.setAttribute('stroke', 'red');
        } else {
          heartPath.setAttribute('fill', 'none');
          heartPath.setAttribute('stroke', 'red');
        }
      }
      state[id].liked = isLiked;
      saveState(state);
      return;
    }
  });
})();
</script>
  <script>
/** ====== CONFIG ====== **/
const API_KEY = "AIzaSyAFnwuMvl4yd2JH31u-UwFlW-_BNLRFlWw"; // for testing only; restrict by referrer!
const CACHE_KEY = "whiskful-i18n-cache-v1";

/** ====== HELPERS ====== **/
const $ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

// elements with visible text to translate
function getTextNodes() {
  return $("[data-translate]");
}

// elements with attributes to translate, e.g. data-translate-attr="placeholder|title"
function getAttrNodes() {
  return $("[data-translate-attr]");
}

function loadCache() {
  try { return JSON.parse(localStorage.getItem(CACHE_KEY)) || {}; }
  catch { return {}; }
}
function saveCache(cache) {
  localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
}

/** Batch translate: send ONE request with many strings **/
async function translateBatch(lines, targetLang) {
  if (!lines.length || targetLang === "en") return lines;

  const url = `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`;
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ q: lines, target: targetLang, format: "text" })
  });
  const json = await res.json();
  if (!json.data || !json.data.translations) throw new Error("Translation failed");
  return json.data.translations.map(t => t.translatedText);
}

/** Apply direction (RTL for Arabic, otherwise LTR) **/
function applyDir(lang) {
  const rtl = ["ar", "fa", "he", "ur"];
  document.documentElement.lang = lang;
  document.documentElement.dir = rtl.includes(lang) ? "rtl" : "ltr";
  document.body.classList.toggle("rtl", rtl.includes(lang));
}

/** Main switcher **/
async function switchLanguage(lang) {
  applyDir(lang);

  // Gather text content nodes
  const textNodes = getTextNodes();
  const originals = textNodes.map(el => {
    // stash original once
    if (!el.dataset.original) el.dataset.original = el.innerText.trim();
    return el.dataset.original;
  });

  // Gather attribute nodes
  const attrNodes = getAttrNodes().flatMap(el => {
    const attrs = el.getAttribute("data-translate-attr").split("|").map(a => a.trim());
    return attrs.map(attr => {
      const key = `attr:${attr}`;
      if (!el.dataset[key]) el.dataset[key] = (el.getAttribute(attr) || "").trim();
      return { el, attr, original: el.dataset[key] };
    });
  });

  // Build full batch list (text + attrs)
  const allOriginals = [
    ...originals,
    ...attrNodes.map(x => x.original)
  ];

  // If English, just restore originals
  if (lang === "en") {
    textNodes.forEach((el, i) => { el.innerText = textNodes[i].dataset.original; });
    attrNodes.forEach(({el, attr}) => { el.setAttribute(attr, el.dataset[`attr:${attr}`]); });
    return;
  }

  // Cache lookup
  const cache = loadCache();
  const toTranslate = [];
  const mapIndex = []; // map from allOriginals index -> position in toTranslate or cache

  allOriginals.forEach((text, idx) => {
    const key = `${lang}::${text}`;
    if (cache[key]) {
      mapIndex[idx] = { fromCache: true, value: cache[key] };
    } else {
      mapIndex[idx] = { fromCache: false, queueIndex: toTranslate.push(text) - 1 };
    }
  });

  // Call API once for the items not in cache
  let translatedQueued = [];
  if (toTranslate.length) {
    translatedQueued = await translateBatch(toTranslate, lang);
    // write new translations to cache
    translatedQueued.forEach((val, i) => {
      const orig = toTranslate[i];
      cache[`${lang}::${orig}`] = val;
    });
    saveCache(cache);
  }

  // Rebuild final list
  const final = allOriginals.map((_, idx) => {
    const m = mapIndex[idx];
    return m.fromCache ? m.value : translatedQueued[m.queueIndex];
  });

  // Apply back: first all text nodes, then attributes
  final.slice(0, originals.length).forEach((val, i) => {
    textNodes[i].textContent = val; // plain text from API; safe to set
  });

  let k = originals.length;
  attrNodes.forEach(({el, attr}, i) => {
    const val = final[k++];
    el.setAttribute(attr, val);
  });
}

/** Hook the switcher **/
const switcher = document.getElementById("language-switcher");
if (switcher) {
  switcher.addEventListener("change", e => switchLanguage(e.target.value));
}

/** Optional: translate on first load based on URL ?lang=xx or saved choice **/
(function initLang(){
  const params = new URLSearchParams(location.search);
  const saved = localStorage.getItem("whiskful-lang");
  const lang = params.get("lang") || saved || "en";
  if (switcher) switcher.value = lang;
  switchLanguage(lang).catch(console.error);
  // remember choice after user changes it
  switcher?.addEventListener("change", () => {
    localStorage.setItem("whiskful-lang", switcher.value);
  });
})();
</script>

    <script>
  /* ===== Cards state & renderer (uses images[]) ===== */
  const CARDS_KEY = "whiskful-cards-v1"; // [{id,url,caption,styles,images:[] }]

  function loadCards(){
    try { return JSON.parse(localStorage.getItem(CARDS_KEY)) || []; }
    catch { return []; }
  }
  function saveCards(cards){
    localStorage.setItem(CARDS_KEY, JSON.stringify(cards));
  }

  // Rebuild cards on page load
  window.addEventListener("DOMContentLoaded", () => {
    const cards = loadCards();
    const grid  = document.querySelector(".grid");
    cards.forEach(card => {
      const fig = renderCard(card);
      grid.appendChild(fig);
    });
    // re-apply current language to rebuilt captions
    const currentLang = document.getElementById("language-switcher")?.value || "en";
    if (typeof switchLanguage === "function") switchLanguage(currentLang);
  });

  function renderCard(card){
    const fig = document.createElement("figure");
    fig.className = "tile";
    fig.dataset.id = card.id;

    fig.innerHTML = `
      <div class="thumb" style="position:relative;">
        <img src="${card.url}" alt="${card.caption || 'Recipe'}" loading="lazy" />
        ${Array.isArray(card.images) && card.images.length > 1
          ? `<span class="album-pill" style="
                position:absolute; top:6px; right:6px;
                padding:2px 6px; border-radius:999px;
                background:rgba(0,0,0,.6); color:#fff; font-size:12px; font-weight:700;">
                +${card.images.length - 1}
             </span>`
          : ""
        }
      </div>
      <figcaption contenteditable="true"
                  class="recipe-title"
                  data-translate
                  style="padding:10px; text-align:center; font-weight:bold;">
      </figcaption>
      <div class="recipe-meta">
        <div class="meta-row">
          <span class="servings" contenteditable="true" data-translate>Serves 6</span> ·
          <span class="totaltime" contenteditable="true" data-translate>Total 45 min</span>
        </div>
      </div>
      <div class="card-actions">
        <button class="save-card-btn">Save Card</button>
      </div>
      <a href="recipe.html?id=${encodeURIComponent(card.id)}" aria-label="Open recipe"></a>
    `;

    const caption = fig.querySelector("figcaption");
    caption.textContent = card.caption || "Enter recipe title here...";
    caption.dataset.original = caption.textContent;

    applyStyles(caption, card.styles);

    // mark editing while typing
    fig.addEventListener("input", () => markEditing(fig, true));
    fig.querySelector(".save-card-btn").addEventListener("click", () => {
      persistFigure(fig);
      markEditing(fig, false);
    });

    // keep your toolbar in sync
    fig.addEventListener("focusin", (e) => {
      const editable = e.target.closest("[contenteditable='true']");
      if (editable && typeof setActiveEditable === "function") setActiveEditable(editable);
    });

    return fig;
  }

  function markEditing(fig, on){
    fig.classList.toggle("editing", !!on);
  }

  function applyStyles(el, styles={}){
    if (!el) return;
    if (styles.fontFamily) el.style.fontFamily = styles.fontFamily;
    if (styles.fontSize)   el.style.fontSize   = styles.fontSize;
    if (styles.color)      el.style.color      = styles.color;
    if (styles.textAlign)  el.style.textAlign  = styles.textAlign;
  }

  // Save a single figure back to localStorage (preserve album)
  function persistFigure(fig){
    const id = fig.dataset.id;
    const captionEl = fig.querySelector("figcaption");
    const img = fig.querySelector("img");

    // update translator seed
    captionEl.dataset.original = captionEl.textContent.trim();

    const cards = loadCards();
    const idx = cards.findIndex(c => c.id === id);
    const styles = {
      fontFamily: captionEl.style.fontFamily || "",
      fontSize:   captionEl.style.fontSize   || "",
      color:      captionEl.style.color      || "",
      textAlign:  captionEl.style.textAlign  || ""
    };
    const base = {
      id,
      url: img.src,
      caption: captionEl.textContent.trim(),
      styles
    };

    if (idx >= 0) {
      const existing = cards[idx];
      // keep any existing album; if none, start one with the cover
      cards[idx] = { ...base, images: Array.isArray(existing.images) ? existing.images : [existing.url] };
    } else {
      cards.push({ ...base, images: [img.src] });
    }
    saveCards(cards);
  }
</script>


    
   <!-- Cloudinary Upload Widget -->
<script src="https://widget.cloudinary.com/v2.0/global/all.js"></script>
<script>
  const cloudName = "danldkifo";
  const uploadPreset = "unsigned_preset";

  // Temporary holder for the album being created/extended
  let pendingAlbum = null;   // { id, images: [], caption, styles }

  // Make sure our style toolbar targets the right element after upload
  function focusToolbarOn(fig){
    // scroll into view & focus the title so toolbar controls apply there
    fig.scrollIntoView({behavior:"smooth", block:"center"});
    const editable = fig.querySelector("[contenteditable='true']");
    editable?.focus();
    // if you have setActiveEditable from earlier steps, keep calling it:
    if (typeof setActiveEditable === "function") setActiveEditable(editable);
  }

  // Create the widget once
  const uploadWidget = cloudinary.createUploadWidget(
    {
      cloudName,
      uploadPreset,
      sources: ["local", "url", "camera"],
      multiple: true,              // ✅ allow multiple files
      showCompletedButton: true,
      cropping: false,
      folder: "recipes"
    },
    (error, result) => {
      if (error) { console.error(error); return; }

      // 1) Each successful file
      if (result?.event === "success") {
        const url = result.info.secure_url;
        const id  = result.info.public_id;

        // if starting a new album
        if (!pendingAlbum) {
          pendingAlbum = {
            id,                                // use first public_id as card id
            images: [url],                     // album starts with first image
            caption: "Enter recipe title here...",
            styles: { fontFamily:"", fontSize:"", color:"", textAlign:"center" }
          };

          // create the visible card immediately (shows first image)
          const grid = document.querySelector(".grid");
          const fig = renderCard({
            id: pendingAlbum.id,
            url: pendingAlbum.images[0],       // first image for the main thumb
            caption: pendingAlbum.caption,
            styles: pendingAlbum.styles,
            images: pendingAlbum.images        // pass the album through
          });
          grid.appendChild(fig);

          // persist a draft right away
          const cards = loadCards();
          cards.push({
            id: pendingAlbum.id,
            url: pendingAlbum.images[0],
            caption: pendingAlbum.caption,
            styles: pendingAlbum.styles,
            images: [...pendingAlbum.images],
          });
          saveCards(cards);

          // translate the new caption to current language (if you use i18n)
          const currentLang = document.getElementById("language-switcher")?.value || "en";
          if (typeof switchLanguage === "function") switchLanguage(currentLang);

          // move the toolbar’s focus to this new card
          const justAdded = grid.querySelector(`figure.tile[data-id="${pendingAlbum.id}"]`);
          if (justAdded) focusToolbarOn(justAdded);
        } else {
          // continuing same album
          pendingAlbum.images.push(url);

          // update the existing card’s stored album
          const cards = loadCards();
          const idx = cards.findIndex(c => c.id === pendingAlbum.id);
          if (idx >= 0) {
            cards[idx].images = [...pendingAlbum.images];
            // keep the main display using the first image
            cards[idx].url = pendingAlbum.images[0];
            saveCards(cards);
          }
        }
      }

      // 2) When all queued uploads finish, “lock in” and clear the temp
      if (result?.event === "queues-end" || result?.event === "close") {
        if (pendingAlbum) {
          // You could show a little toast here like “3 images added”
          pendingAlbum = null;
        }
      }
    }
  );

  // Button handler
  function openUploadWidget() {
    pendingAlbum = null;     // start fresh album for this session
    uploadWidget.open();
  }
</script>
    
    <!-- ===== Inline style toolbar ===== -->
<style>
  .style-bar{
    position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%);
    background:#fff; border:1px solid #e5e5e5; border-radius:12px;
    box-shadow:0 10px 30px rgba(0,0,0,.12);
    padding:8px; display:flex; gap:8px; align-items:center; z-index:9999;
  }
  .style-bar select, .style-bar input[type="color"], .style-bar button{
    height:32px; border-radius:8px; border:1px solid #ddd; background:#fff; padding:0 8px;
  }
  .style-bar .group{ display:flex; gap:6px; align-items:center; }
  .style-bar .muted{ font-size:12px; opacity:.7; margin-right:6px; }
  @media (max-width:640px){ .style-bar{ bottom: 10px; } }
</style>

<div class="style-bar" id="styleBar" hidden>
  <span class="muted">Text:</span>
  <div class="group">
    <select id="fontFamily">
      <option value="">Default</option>
      <option value="Georgia, serif">Georgia</option>
      <option value="'Times New Roman', Times, serif">Times</option>
      <option value="'Trebuchet MS', system-ui, sans-serif">Trebuchet</option>
      <option value="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">System</option>
    </select>
    <select id="fontSize">
      <option value="">Size</option>
      <option>16px</option><option>18px</option><option selected>20px</option>
      <option>24px</option><option>28px</option><option>32px</option>
    </select>
    <input type="color" id="fontColor" title="Text color" />
  </div>
  <div class="group">
    <button type="button" data-align="left">Left</button>
    <button type="button" data-align="center">Center</button>
    <button type="button" data-align="right">Right</button>
  </div>
</div>

<script>
  // --- Simple style toolbar wiring ---
  let ACTIVE_EDITABLE = null;

  // expose this so renderCard() can call it (you referenced it earlier)
  window.setActiveEditable = function(el){
    ACTIVE_EDITABLE = el;
    // reflect current styles in controls
    fontFamily.value = el.style.fontFamily || "";
    fontSize.value   = el.style.fontSize   || "20px";
    fontColor.value  = rgbToHex(getComputedStyle(el).color);
    styleBar.hidden  = false;
  };

  // Show toolbar when user clicks in any contenteditable within a tile
  document.addEventListener('focusin', (e) => {
    const el = e.target.closest('.tile [contenteditable="true"]');
    if (el) window.setActiveEditable(el);
  });
  // Hide toolbar if focus leaves editable areas
  document.addEventListener('click', (e) => {
    const insideEditable = e.target.closest('.tile [contenteditable="true"]');
    const insideBar = e.target.closest('#styleBar');
    if (!insideEditable && !insideBar) styleBar.hidden = true;
  });

  // controls
  const styleBar   = document.getElementById('styleBar');
  const fontFamily = document.getElementById('fontFamily');
  const fontSize   = document.getElementById('fontSize');
  const fontColor  = document.getElementById('fontColor');

  fontFamily.addEventListener('change', () => applyStyle('fontFamily', fontFamily.value));
  fontSize.addEventListener('change',   () => applyStyle('fontSize', fontSize.value));
  fontColor.addEventListener('input',   () => applyStyle('color', fontColor.value));
  styleBar.querySelectorAll('button[data-align]').forEach(btn => {
    btn.addEventListener('click', () => applyStyle('textAlign', btn.dataset.align));
  });

  function applyStyle(prop, value){
    if (!ACTIVE_EDITABLE) return;
    ACTIVE_EDITABLE.style[prop] = value;
    // mark the figure as editing so user sees dashed outline (your CSS already handles this)
    const fig = ACTIVE_EDITABLE.closest('.tile');
    fig && fig.classList.add('editing');
  }

  // util: rgb() -> #rrggbb for color input sync
  function rgbToHex(rgb){
    const m = rgb.match(/\d+/g);
    if (!m) return '#000000';
    const [r,g,b] = m.map(n => (+n).toString(16).padStart(2,'0'));
    return `#${r}${g}${b}`;
  }
</script>

    <button onclick="openUploadWidget()"
        style="margin:20px; padding:10px 16px; background:#ff7a59; color:#fff; border:none; border-radius:8px; cursor:pointer;">
  ➕ Add New Recipe
</button>
    
  </body>
</html>
