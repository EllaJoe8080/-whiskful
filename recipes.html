<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Whiskful Recipes</title>
    <style>
      /* Make the whole card clickable, but keep it BELOW the buttons */
.tile > a {
    position: absolute;
    inset: 0;
    z-index: 1;
    display: block;
    cursor: pointer;
  }

  /* Add focus outline for keyboard users */
  .tile > a:focus-visible {
    outline: 3px solid var(--brand);
    outline-offset: -3px;
  }

  /* Keep buttons above the link */
  .overlay {
    z-index: 2;
  }

  :root { --brand:#ff7a59; --bg:#fff8f3; --pin:#e60023;}

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background: var(--bg);
        color:#222;
      }

      /* Navbar */
      nav {
        position:sticky; top:0; z-index:1000;
        height:72px; padding:0 24px; background:#fff;
        box-shadow:0 2px 8px rgba(0,0,0,.06);
        display:flex; align-items:center; justify-content:space-between;
      }
      nav img.logo { max-height:140px; width:auto; display:block; }
      nav ul {
  list-style: none;
  display: flex;
  gap: 24px;
  margin-left: auto;   /* pushes menu to the right */
}

nav select#language-switcher {
  margin-left: 16px;   /* small gap after the menu */
}
      nav a { text-decoration:none; font-weight:600; color:#333; }
      nav a:hover { color:var(--brand); }

      /* Search bar */
      .search-wrap { display:flex; justify-content:center; margin:28px 0 8px; }
      .search-box { position:relative; width:min(640px,92%); }
      .search-box input {
        width:100%; padding:12px 16px;
        border:2px solid var(--brand); border-radius:999px;
        font-size:16px; background:#fff;
      }
      .search-box input:focus {
        border-color:#ff5a36; box-shadow:0 0 8px rgba(255,122,89,.3);
        outline: none;
      }
      .dangling-gif {
        position:absolute; top:-22px; right:-50px; width:100px;
        pointer-events:none; transform-origin:top center;
        animation:sway 2.5s ease-in-out infinite;
      }
      @keyframes sway {
        0%{transform:rotate(6deg)} 50%{transform:rotate(-6deg)} 100%{transform:rotate(6deg)}
      }

      /* Grid */
      .grid {
        width:min(1100px,94%);
        margin:12px auto 64px;
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(260px, 1fr));
        gap:12px;
      }

      .tile {
        background:#fff; border-radius:8px; overflow:hidden;
        box-shadow:0 1px 6px rgba(0,0,0,.05);
        transition:transform .15s ease, box-shadow .15s ease;
        position:relative;
      }
      .tile:hover { transform:translateY(-2px); box-shadow:0 10px 24px rgba(0,0,0,.12); }

      .thumb {
        aspect-ratio:2/3;
        background:#fafafa;
        display:flex; align-items:center; justify-content:center;
        padding:4px; /* keep some breathing room inside */
      }
      .thumb img {
        width:100%; height:100%; object-fit:cover; display:block;
      }

      /* Overlay for Save + Like */
      .overlay {
        position:absolute;
        inset:4px;  /* matches .thumb padding */
        pointer-events:none;
        opacity:0;
        transition:opacity .2s ease;
      }
      .tile:hover .overlay { opacity:1; }

      .save-btn, .icon-btn {
        position:absolute; top:10px; pointer-events:auto;
      }

      .save-btn {
        left:10px;
        border:0; border-radius:22px;
        background:var(--pin); color:#fff; font-weight:700;
        padding:8px 16px; font-size:14px; line-height:1;
        box-shadow:0 4px 12px rgba(0,0,0,.25);
        cursor:pointer;
        transition:transform .15s ease, background .15s ease;
      }
      .save-btn:hover { transform:scale(1.05); background:#c7001c; }

      .icon-btn {
        right:10px;
        width:36px; height:36px; border-radius:50%;
        display:grid; place-items:center;
        background:#fff; border:0; cursor:pointer;
        box-shadow:0 3px 10px rgba(0,0,0,.2);
        transition:transform .15s ease, background .15s ease;
      }
      .icon-btn:hover { transform:scale(1.06); }
      .icon-btn svg { display:block; }

      /* Responsive tweaks */
      @media (max-width:640px){
        .grid { grid-template-columns:repeat(auto-fill, minmax(160px, 1fr)); }
        .dangling-gif { right:-34px; top:-16px; width:74px; }
      }
      /* ---- Falling leaves layer ---- */
#leaf-layer{
  position: fixed;
  inset: 0;
  z-index: 0;            /* behind nav/grid */
  pointer-events: none;
  overflow: hidden;
}

/* a single leaf */
.leaf{
  --size: 80px;
  position: absolute;
  top: -12vh;
  width: var(--size);
  height: var(--size);
  opacity: 0;
  filter: drop-shadow(0 6px 6px rgba(0,0,0,.18));
  animation: leaf-move var(--dur) linear var(--delay) forwards;
}

@keyframes leaf-move {
  0%   { transform: translate(var(--start-x), -12vh) rotate(var(--rot-start)); opacity: 0; }
  10%  { opacity: 1; }
  25%  { transform: translate(calc(var(--start-x) + var(--amp)), 25vh) rotate(45deg); }
  50%  { transform: translate(calc(var(--start-x) - var(--amp)), 50vh) rotate(120deg); }
  75%  { transform: translate(calc(var(--start-x) + var(--amp)), 75vh) rotate(200deg); }
  100% { transform: translate(var(--end-x), 110vh) rotate(var(--rot-end)); opacity: 0; }
}

/* accessibility */
@media (prefers-reduced-motion: reduce){
  .leaf{ animation: none !important; opacity: 0; }
}
      /* Active states */
.save-btn.saved {
  background: #16a34a;   /* green when saved */
  box-shadow: 0 4px 12px rgba(22,163,74,.25);
}

.icon-btn.liked svg path {
  fill: red;              /* heart fills when liked */
  stroke: red;
}
    </style>
  </head>
  <body>
    <!-- Falling leaves background layer -->
<div id="leaf-layer" aria-hidden="true"></div>
    <!-- Navbar -->
    <nav>
  <a href="index.html"><img src="/logo.png" alt="Whiskful logo" class="logo" /></a>
  <ul>
    <li><a href="recipes.html" data-translate>Recipes</a></li>
    <li><a href="#" data-translate>Community</a></li>
    <li><a href="#" data-translate>About</a></li>
  </ul>
  <select id="language-switcher" aria-label="Change language">
    <option value="en">English</option>
    <option value="es">Español</option>
    <option value="fr">Français</option>
    <option value="ar">العربية</option>
    <option value="zh">中文</option>
  </select>
</nav>

    <!-- Search -->
    <div class="search-wrap">
      <div class="search-box">
        <input
  type="text"
  placeholder="Search recipes..."
  data-translate-attr="placeholder"
/>
        <img src="/images/cherries.gif" alt="" class="dangling-gif" />
      </div>
    </div>

    <!-- Grid -->
    <main class="grid">
      <!-- pistachio-chocolate-roll -->
      <figure class="tile" data-id="pistachio-roll">
  <div class="thumb">
    <img src="/images/pistachio-chocolate-roll.png" alt="Pistachio Chocolate Swiss Roll" loading="lazy" />
  </div>

  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div>

<a href="pistachio-roll.html" aria-label="View Pistachio Chocolate Swiss Roll recipe"></a>
</figure>
 <!-- Pumpkin Cheesecake Truffles -->
  <figure class="tile" data-id="pumpkin-truffles">
  <div class="thumb">
    <img src="/images/pumpkin cheesecake truffles.jpeg" alt="Pumpkin Cheesecake Truffles" loading="lazy" />
  </div>
  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div>
  <a href="pumpkin-truffles.html" aria-label="View Pumpkin Cheesecake Truffles recipe"></a>
</figure>
 <!-- Strawberry Meringue kisses -->
     <figure class="tile" data-id="strawberry-meringue">
  <div class="thumb">
    <img src="/images/Strawberry Meringue kisses.jpeg" alt="Strawberry Meringue Kisses" loading="lazy" />
  </div>
  <div class="overlay">
    <button class="save-btn" type="button" aria-pressed="false">Save</button>
    <button class="icon-btn" type="button" aria-pressed="false" aria-label="Like">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
        <path d="M12 21s-6.5-4.35-9.33-7.64C-1.17 9.1 2.5 3 7.5 5.09 9.24 5.83 12 9 12 9s2.76-3.17 4.5-3.91c5-2.09 8.67 4.01 4.83 8.27C18.5 16.65 12 21 12 21z"
              fill="none" stroke="red" stroke-width="2"/>
      </svg>
    </button>
  </div><a href="strawberry-meringue.html" aria-label="View Strawberry Meringue Kisses recipe"></a>
</figure>
      
    </main>
    <script>
(() => {
  // stop if user prefers reduced motion
  if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

  const layer = document.getElementById('leaf-layer');
  if (!layer) return;

  // Put these four PNGs in /images/ (transparent backgrounds)
  const LEAVES = [
    '/images/leaf1.png',
    '/images/leaf2.png',
    '/images/leaf3.png',
    '/images/leaf4.png'
  ];

  const CFG = {
  minInterval: 400,   // slower spawn rate, not overwhelming
  maxInterval: 1200,
  minDur: 4500,       // smoother fall
  maxDur: 7500,
  minSize: 80,        // larger minimum
  maxSize: 150,       // larger maximum
  minAmp: 40,         // bigger sway
  maxAmp: 120,
  maxConcurrent: 8    // more leaves at once
};

  let live = 0;
  const rand = (a,b) => Math.random()*(b-a)+a;

  function spawnLeaf(){
    if (live >= CFG.maxConcurrent) return;

    const img = document.createElement('img');
    img.className = 'leaf';
    img.src = LEAVES[Math.floor(Math.random()*LEAVES.length)];

    const size    = rand(CFG.minSize, CFG.maxSize);
    const dur     = rand(CFG.minDur,  CFG.maxDur);
    const startX  = rand(0, innerWidth);
    const endX    = startX + rand(-140, 140);
    const amp     = rand(CFG.minAmp, CFG.maxAmp);

    img.style.setProperty('--size', `${size}px`);
    img.style.setProperty('--dur',  `${dur}ms`);
    img.style.setProperty('--delay', '0ms');
    img.style.setProperty('--start-x', `${startX}px`);
    img.style.setProperty('--end-x',   `${endX}px`);
    img.style.setProperty('--amp',     `${amp}px`);
    img.style.setProperty('--rot-start', `${rand(-25,25)}deg`);
    img.style.setProperty('--rot-end',   `${rand(-360,360)}deg`);
    img.style.left = `${startX}px`;

    img.addEventListener('animationend', () => { img.remove(); live--; }, {once:true});

    live++;
    layer.appendChild(img);
  }

  function loop(){
    spawnLeaf();
    setTimeout(loop, rand(CFG.minInterval, CFG.maxInterval));
  }
  requestAnimationFrame(loop);
})();
</script>
    <script>
(() => {
  const STORAGE_KEY = 'whiskful-tile-states';  // { [tileId]: { liked:bool, saved:bool } }

  function loadState() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
    catch { return {}; }
  }
  function saveState(state) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  // Apply saved state on load
  const state = loadState();
  document.querySelectorAll('.tile[data-id]').forEach(tile => {
    const id = tile.getAttribute('data-id');
    const s = state[id] || {};
    const saveBtn = tile.querySelector('.save-btn');
    const likeBtn = tile.querySelector('.icon-btn');
    const heartPath = likeBtn?.querySelector('svg path');

    // Saved
    if (s.saved) {
      saveBtn?.classList.add('saved');
      saveBtn?.setAttribute('aria-pressed', 'true');
      if (saveBtn) saveBtn.textContent = 'Saved';
    }

    // Liked
    if (s.liked) {
      likeBtn?.classList.add('liked');
      likeBtn?.setAttribute('aria-pressed', 'true');
      if (heartPath) {
        heartPath.setAttribute('fill', 'red');
        heartPath.setAttribute('stroke', 'red');
      }
    }
  });

  // Click handling (event delegation)
  document.addEventListener('click', (e) => {
    const saveBtn = e.target.closest('.save-btn');
    const likeBtn = e.target.closest('.icon-btn');

    if (!saveBtn && !likeBtn) return;

    const tile = e.target.closest('.tile[data-id]');
    if (!tile) return;
    const id = tile.getAttribute('data-id');
    state[id] ||= { liked: false, saved: false };

    // SAVE toggle
    if (saveBtn) {
      e.preventDefault();
      const isSaved = saveBtn.classList.toggle('saved');
      saveBtn.setAttribute('aria-pressed', String(isSaved));
      saveBtn.textContent = isSaved ? 'Saved' : 'Save';
      state[id].saved = isSaved;
      saveState(state);
      return;
    }

    // LIKE toggle
    if (likeBtn) {
      e.preventDefault();
      const isLiked = likeBtn.classList.toggle('liked');
      likeBtn.setAttribute('aria-pressed', String(isLiked));
      const heartPath = likeBtn.querySelector('svg path');
      if (heartPath) {
        if (isLiked) {
          heartPath.setAttribute('fill', 'red');
          heartPath.setAttribute('stroke', 'red');
        } else {
          heartPath.setAttribute('fill', 'none');
          heartPath.setAttribute('stroke', 'red');
        }
      }
      state[id].liked = isLiked;
      saveState(state);
      return;
    }
  });
})();
</script>
  <script>
/** ====== CONFIG ====== **/
const API_KEY = "AIzaSyAFnwuMvl4yd2JH31u-UwFlW-_BNLRFlWw"; // for testing only; restrict by referrer!
const CACHE_KEY = "whiskful-i18n-cache-v1";

/** ====== HELPERS ====== **/
const $ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

// elements with visible text to translate
function getTextNodes() {
  return $("[data-translate]");
}

// elements with attributes to translate, e.g. data-translate-attr="placeholder|title"
function getAttrNodes() {
  return $("[data-translate-attr]");
}

function loadCache() {
  try { return JSON.parse(localStorage.getItem(CACHE_KEY)) || {}; }
  catch { return {}; }
}
function saveCache(cache) {
  localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
}

/** Batch translate: send ONE request with many strings **/
async function translateBatch(lines, targetLang) {
  if (!lines.length || targetLang === "en") return lines;

  const url = `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`;
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ q: lines, target: targetLang, format: "text" })
  });
  const json = await res.json();
  if (!json.data || !json.data.translations) throw new Error("Translation failed");
  return json.data.translations.map(t => t.translatedText);
}

/** Apply direction (RTL for Arabic, otherwise LTR) **/
function applyDir(lang) {
  const rtl = ["ar", "fa", "he", "ur"];
  document.documentElement.lang = lang;
  document.documentElement.dir = rtl.includes(lang) ? "rtl" : "ltr";
  document.body.classList.toggle("rtl", rtl.includes(lang));
}

/** Main switcher **/
async function switchLanguage(lang) {
  applyDir(lang);

  // Gather text content nodes
  const textNodes = getTextNodes();
  const originals = textNodes.map(el => {
    // stash original once
    if (!el.dataset.original) el.dataset.original = el.innerText.trim();
    return el.dataset.original;
  });

  // Gather attribute nodes
  const attrNodes = getAttrNodes().flatMap(el => {
    const attrs = el.getAttribute("data-translate-attr").split("|").map(a => a.trim());
    return attrs.map(attr => {
      const key = `attr:${attr}`;
      if (!el.dataset[key]) el.dataset[key] = (el.getAttribute(attr) || "").trim();
      return { el, attr, original: el.dataset[key] };
    });
  });

  // Build full batch list (text + attrs)
  const allOriginals = [
    ...originals,
    ...attrNodes.map(x => x.original)
  ];

  // If English, just restore originals
  if (lang === "en") {
    textNodes.forEach((el, i) => { el.innerText = textNodes[i].dataset.original; });
    attrNodes.forEach(({el, attr}) => { el.setAttribute(attr, el.dataset[`attr:${attr}`]); });
    return;
  }

  // Cache lookup
  const cache = loadCache();
  const toTranslate = [];
  const mapIndex = []; // map from allOriginals index -> position in toTranslate or cache

  allOriginals.forEach((text, idx) => {
    const key = `${lang}::${text}`;
    if (cache[key]) {
      mapIndex[idx] = { fromCache: true, value: cache[key] };
    } else {
      mapIndex[idx] = { fromCache: false, queueIndex: toTranslate.push(text) - 1 };
    }
  });

  // Call API once for the items not in cache
  let translatedQueued = [];
  if (toTranslate.length) {
    translatedQueued = await translateBatch(toTranslate, lang);
    // write new translations to cache
    translatedQueued.forEach((val, i) => {
      const orig = toTranslate[i];
      cache[`${lang}::${orig}`] = val;
    });
    saveCache(cache);
  }

  // Rebuild final list
  const final = allOriginals.map((_, idx) => {
    const m = mapIndex[idx];
    return m.fromCache ? m.value : translatedQueued[m.queueIndex];
  });

  // Apply back: first all text nodes, then attributes
  final.slice(0, originals.length).forEach((val, i) => {
    textNodes[i].textContent = val; // plain text from API; safe to set
  });

  let k = originals.length;
  attrNodes.forEach(({el, attr}, i) => {
    const val = final[k++];
    el.setAttribute(attr, val);
  });
}

/** Hook the switcher **/
const switcher = document.getElementById("language-switcher");
if (switcher) {
  switcher.addEventListener("change", e => switchLanguage(e.target.value));
}

/** Optional: translate on first load based on URL ?lang=xx or saved choice **/
(function initLang(){
  const params = new URLSearchParams(location.search);
  const saved = localStorage.getItem("whiskful-lang");
  const lang = params.get("lang") || saved || "en";
  if (switcher) switcher.value = lang;
  switchLanguage(lang).catch(console.error);
  // remember choice after user changes it
  switcher?.addEventListener("change", () => {
    localStorage.setItem("whiskful-lang", switcher.value);
  });
})();
</script>
    <!-- Cloudinary Upload Widget -->
<script src="https://widget.cloudinary.com/v2.0/global/all.js" type="text/javascript"></script>
<script>
  const cloudName = "YOUR_CLOUD_NAME"; // replace with your Cloudinary cloud name
  const uploadPreset = "unsigned_preset"; // the one you just created

  // Open the widget when the button is clicked
  function openUploadWidget() {
    cloudinary.openUploadWidget(
      {
        cloudName: cloudName,
        uploadPreset: uploadPreset,
        sources: ["local", "url", "camera"], // allow local files, URLs, or camera
        multiple: false,
        cropping: false,
        folder: "recipes", // optional: organize uploads
      },
      (error, result) => {
        if (!error && result && result.event === "success") {
          console.log("Uploaded image:", result.info.secure_url);

          // Example: add new recipe card dynamically
          const grid = document.querySelector(".grid");
          const newCard = document.createElement("figure");
          newCard.className = "tile";
          newCard.innerHTML = `
            <div class="thumb">
              <img src="${result.info.secure_url}" alt="New Recipe" loading="lazy" />
            </div>
            <figcaption contenteditable="true" style="padding:10px; text-align:center; font-weight:bold;" data-translate>
              Enter recipe title here...
            </figcaption>
          `;
          grid.appendChild(newCard);
        }
      }
    ).open();
  }
</script>

<!-- Button to trigger upload -->
<button onclick="openUploadWidget()" style="margin:20px; padding:10px 16px; background:#ff7a59; color:#fff; border:none; border-radius:8px; cursor:pointer;">
  ➕ Add New Recipe
</button>
  </body>
</html>
